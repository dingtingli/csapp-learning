# 从程序的角度看，内存是什么？

## 内存的基本概念

我们可以把内存理解为一个数组，其中每个元素可以保存 1 字节（byte）的数据。

在数组中访问一个元素可以使用索引，同样为了能访问内存中的元素，每个元素都有自己的地址。

从上面的描述中，我们可以看出：
1. 内存的最小空间是1个字节（byte）。
2. 内存是由许多这样的空间组合在一起的。
3. 每个空间都有一个地址。

我们以一个 4 位寻址空间的内存为例，用图形模拟一下内存的形象（只是模拟，真实的内存不是这样的）。

所谓 4 位 寻址空间，是指内存地址的范围是用 4 位（bit）的二进制表示，从 0000 到 1111，换算成十进制就是 0 - 15。每个地址可以保存 1 个字节（byte）的数据，因此这个内存的容量就是 16 个字节。

1111
1110
1101
1100
1011
1010
1001
1000
0111
0110
0101
0100
0011
0010
0001
0000

Q: 为什么内存最小空间是 1 个字节（byte）？ 

## 64位操作系统内存空间

现在的操作系统都是 64 位，意思就是可以使用的内存地址范围是：

0000000000000000000000000000000000000000000000000000000000000000（64个0）

~

1111111111111111111111111111111111111111111111111111111111111111（64个1）

二进制的显示太长，换算成十六进制：

0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF

这么大的内存寻址空间，最多可以存储多少数据？

2的64次方 = 18,446,744,073,709,551,616 字节（byte），大概是16,777,216 TB。

这个数字跟我们的实际经验是不一致的，我们的个人电脑，内存大概就是 8/16/32 GB，现实生活中也不可能有这么大的内存。

那么我们为什么还要讨论这个看上去不太现实的寻址空间呢？这时候我们就需要切换一下视角，从程序的角度来看看内存是什么样子的？

Q:32位操作系统的内存寻址空间是多少？

## 程序角度的内存

我们可以想象一下，一台有 32 G 内存的计算机，正在运行着浏览器，Word 等程序。这时候内存的使用情况大概是什么样子呢？

打开 Windows 电脑的任务管理器我们就能看到，每个程序都占用着一定数量的内存。

看到这我们可能会认为，这些程序直接操作着内存中的某个区域。

然而真实情况是，程序本事是无法直接操作物理内存，程序所能操作的是**虚拟内存**。

这个虚拟内存有这么几个特点：

1. 每个程序都感觉自己单独拥有系统的整个内存。

2. 每个程序可以看到的内存地址范围是 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，而不是计算机真实的内存寻址空间。

3. 每个程序实际可以使用的内存寻址空间是 0x0000000000000000 ~ 0x00007FFFFFFFFFFF 。0x0000800000000000 ~ 0xFFFFFFFFFFFFFFFF 这个寻址空间的内存属于操作系统内核虚拟内存。

也就是说每个程序都感觉自己拥有了完整的64位寻址空间的内存。

看到这里我们肯定会好奇：

    * 虚拟内存是什么技术？
    * 虚拟内存如何映射到物理内存？
    * 虚拟内存这么大，如果程序使用范围了超出物理内存的空间，会发生什么情况？
    ...

这些问题都需要理解虚拟内存这项技术之后才能解答。

现阶段我们只需知道，每个程序看到的内存都是操作系统所能提供的完整寻址空间的内存，并且有一个叫虚拟内存的技术，可以将程序在这里使用的内存映射到物理内存上。

## 程序视角内存的布局

作为一个程序员，我首先整理一下自己知道的内存相关的常识：
1. 写出来的代码文件，最终会编译成可执行文件。
2. 听说过堆（Heap）和栈（Stack），但是不太清楚。

从程序的视角来看，了解内存的布局可以对上面的常识有一个比较深入的理解。

 
```c
char big_array1[1L << 24];  /*16M*/
char huge_array[1L << 31];  /*2G*/

int global = 0;

int useless() { return 0; }

int main()
{
    void *p1, *p2, *p3, *p4;
    int local = 0;
    p1 = malloc(1L << 28);  /*256M*/
    p2 = malloc(1L << 8);   /*256B*/
    p3 = malloc(1L << 32);  /*4G*/
    p4 = malloc(1L << 8);   /*256B*/
}
```