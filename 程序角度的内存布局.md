# 从程序的角度看，内存的布局是什么样子？

## 程序视角的内存布局

[上一篇文章](/程序角度的内存.md)中，我们已经了解了从程序的视角来看，内存是什么样子。那么程序是如何使用内存的呢？

这就需要知道程序对内存的布局是什么样子的？

在开始研究内存布局之前，让我们先来整理一下编写代码过程中可能会了解到的一些关于内存的知识点：

1. 编写的代码文件，会被编译成可执行文件。
2. 可执行文件会被加载到内存后再执行。
3. 变量有值和引用两种类型，被分配在不同的内存空间（堆（Heap）和栈（Stack））。
4. c 语言中的指针，指向的是内存的地址。

研究内存的布局可以对上面的知识点有更深入的理解。

我们从一段 c 语言代码开始，这段代码是从 CMU 15-213 CSAPP 课件中找到的。

*c 语言开发环境的设置，请参考文末的链接。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

char big_array1[1L << 24];  /*16M*/
char huge_array[1L << 31];  /*2G*/

int global = 0;

int useless() { return 0; }

int main()
{
    void *p1, *p2, *p3, *p4;
    int local = 0;
    p1 = malloc(1L << 28);  /*256M*/
    p2 = malloc(1L << 8);   /*256B*/
    p3 = malloc(1L << 32);  /*4G*/
    p4 = malloc(1L << 8);   /*256B*/

    //some print points statements
}
```


我们先来理解一下这段代码：

1. `char big_array1[1L << 24];`
    
    * `1L` 是一个值为 1 的 long 类型（64位）数值；

    * `1L << 24` 是将 1 左移 24，得到的值等于 2 的 24 次方，16,777,216。

    * `char` 类型的值是 1 个字节，所以 `char big_array1[1L << 24];` 这个数组需要 16,777,216 个字节，也就是 16 M。

2. `big_array1`，`huge_array` 和 `global` 为全局变量。

3. `useless` 是一个函数。

4. `local` 是 `main` 中的局部变量。

5. `malloc` 函数的作用是在内存中手动分配空间，参数为分配空间的字节数。

6. `p1` 定义为指针，指向 malloc 分配内存空间的首地址。

这段代码没有什么实际用途，主要就是在内存中分配空间。我们可以通过输出不同变量的地址，来查看程序内存的布局。

*输出变量地址的完整 c 语言代码在文章结尾。

|section|name|memory address|address dec|
|:--|:--|:--|:--|
|stack |local     |0x00007ffc1bc2e8e4 |140720774244580|
|heap |p1         |0x00007f64a8d9b010 |140070306295824|
|heap |p3         |0x00007f63a8d9a010 |140066011324432|
|heap |p2         |0x000055c1686622a0 |94289168573088|
|heap |p4         |0x000055c1686623b0 |94289168573360|
|data |huge_array |0x000055c0e673b040 |94286988423232|
|data |big_array  |0x000055c0e573b040 |94286971646016|
|data |global     |0x000055c0e573b024 |94286971645988|
|text |code useless       |0x000055c0e57381a9 |94286971634089|
|text |code main  |0x000055c0e57381db |94286971634139|

* 第一列是内存所在区域的功能名称：stack，heap，data，text
* 第二列是代码中的变量和函数
* 第三列是变量和函数对应的内存的起始地址（即指针）
* 第四列是内存地址对应的十进制表示

从中我们可以看到内存布局的概况。

stack
heap
...
heap
data
text

从下往上看，

为了更加精确的知道每个区域的详细位置，我们使用了命令 pmap 来查看内存的详细信息

```cmd
pmap -X `pidof malloc`
```


12081:   ./malloc
     Address Perm   Offset Device Inode    Size  Rss Pss Referenced Anonymous LazyFree ShmemPmdMapped FilePmdMapped Shared_Hugetlb Private_Hugetlb Swap SwapPss Locked THPeligible Mapping
55c0e5737000 r--p 00000000  08:20 78312       4    4   4          4         0        0              0             0              0               0    0       0      0           0 malloc
55c0e5738000 r-xp 00001000  08:20 78312       4    4   4          4         0        0              0             0              0               0    0       0      0           0 malloc
55c0e5739000 r--p 00002000  08:20 78312       4    4   4          4         0        0              0             0              0               0    0       0      0           0 malloc
55c0e573a000 r--p 00002000  08:20 78312       4    4   4          4         4        0              0             0              0               0    0       0      0           0 malloc
55c0e573b000 rw-p 00003000  08:20 78312       4    4   4          4         4        0              0             0              0               0    0       0      0           0 malloc
55c0e573c000 rw-p 00000000  00:00     0 2113536    0   0          0         0        0              0             0              0               0    0       0      0           1
55c168662000 rw-p 00000000  00:00     0     132    4   4          4         4        0              0             0              0               0    0       0      0           0 [heap]
7f63a8d9a000 rw-p 00000000  00:00     0 4456456    8   8          8         8        0              0             0              0               0    0       0      0           1
7f64b8d9c000 r--p 00000000  08:20 40180     148  144   5        144         0        0              0             0              0               0    0       0      0           0 libc-2.31.so
7f64b8dc1000 r-xp 00025000  08:20 40180    1504  944  40        944         0        0              0             0              0               0    0       0      0           0 libc-2.31.so
7f64b8f39000 r--p 0019d000  08:20 40180     296  124   4        124         0        0              0             0              0               0    0       0      0           0 libc-2.31.so
7f64b8f83000 ---p 001e7000  08:20 40180       4    0   0          0         0        0              0             0              0               0    0       0      0           0 libc-2.31.so
7f64b8f84000 r--p 001e7000  08:20 40180      12   12  12         12        12        0              0             0              0               0    0       0      0           0 libc-2.31.so
7f64b8f87000 rw-p 001ea000  08:20 40180      12   12  12         12        12        0              0             0              0               0    0       0      0           0 libc-2.31.so
7f64b8f8a000 rw-p 00000000  00:00     0      24   24  24         24        24        0              0             0              0               0    0       0      0           0
7f64b8f9e000 r--p 00000000  08:20 40176       4    4   0          4         0        0              0             0              0               0    0       0      0           0 ld-2.31.so
7f64b8f9f000 r-xp 00001000  08:20 40176     140  140   5        140         0        0              0             0              0               0    0       0      0           0 ld-2.31.so
7f64b8fc2000 r--p 00024000  08:20 40176      32   32   1         32         0        0              0             0              0               0    0       0      0           0 ld-2.31.so
7f64b8fcb000 r--p 0002c000  08:20 40176       4    4   4          4         4        0              0             0              0               0    0       0      0           0 ld-2.31.so
7f64b8fcc000 rw-p 0002d000  08:20 40176       4    4   4          4         4        0              0             0              0               0    0       0      0           0 ld-2.31.so
7f64b8fcd000 rw-p 00000000  00:00     0       4    4   4          4         4        0              0             0              0               0    0       0      0           0
7ffc1bc0f000 rw-p 00000000  00:00     0     132   12  12         12        12        0              0             0              0               0    0       0      0           0 [stack]
7ffc1bcb5000 r--p 00000000  00:00     0      16    0   0          0         0        0              0             0              0               0    0       0      0           0 [vvar]
7ffc1bcb9000 r-xp 00000000  00:00     0       4    4   0          4         0        0              0             0              0               0    0       0      0           0 [vdso]
                                        ======= ==== === ========== ========= ======== ============== ============= ============== =============== ==== ======= ====== ===========
                                        6572484 1496 159       1496        92        0              0             0              0               0    0       0      0           2 KB

附录：

输出地址的完整 c 语言代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void show_pointer(void *p, char *descr)
{
    printf("%s\t%p\t%lu\n", descr, p, (unsigned long)p);
}

char big_array1[1L << 24]; /*16M*/
char huge_array[1L << 31]; /*2G*/

int global = 0;

int useless() { return 0; }

int main()
{
    void *p1, *p2, *p3, *p4;
    int local = 0;
    p1 = malloc(1L << 28); /*256M*/
    p2 = malloc(1L << 8);  /*256B*/
    p3 = malloc(1L << 32); /*4G*/
    p4 = malloc(1L << 8);

    show_pointer((void *)&local, "stack local");
    show_pointer((void *)p1, "heap p1\t");
    show_pointer((void *)p3, "heap p3\t");
    show_pointer((void *)p2, "heap p2\t");
    show_pointer((void *)p4, "heap p4\t");
    show_pointer((void *)huge_array, "data huge_array");
    show_pointer((void *)big_array1, "data big_array");
    show_pointer((void *)&global, "data global");
    show_pointer((void *)useless, "text code useless");
    show_pointer((void *)main, "text code main");
    pause(); // for pmap command
}
```


| 注意: |
| :--- |
| 如何准备 c 语言的运行环境，可以参考下面的文章列表。在文章中我们介绍了使用 WSL 安装 Ubuntu 并设置 c 语言的开发和调试环境。 |
| [WSL 01 -- 安装 Ubuntu](/准备Linux环境.md) |
| [WSL 02 -- Ubuntu 中安装 GUI 应用](/使用Ubuntu01.md) |
| [WSL 03 -- 访问文件目录](/使用Ubuntu02.md) |
| [WSL 04 -- gcc](/使用Ubuntu03.md) |
| [WSL 05 -- VS Code](/使用Ubuntu04.md) |
| [WSL 06 -- gdb](/使用Ubuntu05.md) |