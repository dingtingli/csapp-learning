# 递归（recursion）

我们在之前的文章中详细介绍了[栈帧（Stack Frame）](./栈帧的布局.md)的概念，通过栈帧使得每次函数调用都有了他们自己的私有信息存储空间，而这一切都是递归（recursion）实现的基础。

## 什么是递归

首先通过一段示例来回忆一下递归的基本含义。

下面这段 c 语言代码，主要是用来求阶乘的。比如 `3！` 就等于 `3 * 2 * 1`，我们可看出来 `n! = n * (n-1)！`。

```c
long rfact(long n)
{
    long result;

    if(n <= 1)
        result = 1;
    else
        result = n * rfact(n-1);
    
    return result;
}

int main()
{
    long i = rfact(3);
    return 0;
}
```

代码中 `rfact` 就实现了 `n！` 的求解，其中 `result = n * rfact(n-1);` 的意思就是 `n! = n * (n-1)！`。

这句代码我们可以看到 `rfact` 函数内部调用了自己，这就是**递归**，函数可以调用自身。

那这段代码是如何运行的，我们通过观察 Stack（栈）和寄存器的变化来详细了解一下。

## 递归的运行

上面的 `rfact` 函数编译后的指令集如下：

```arm
0x555555555129 <rfact>:
    0x555555555129:       f3 0f 1e fa         endbr64 
    0x55555555512d:       48 83 ff 01         cmp    $0x1,%rdi
    0x555555555131:       7f 06               jg     0x555555555139 <rfact+0x10>
    0x555555555133:       b8 01 00 00 00      mov    $0x1,%eax
    0x555555555138:       c3                  retq   
    0x555555555139:       53                  push   %rbx
    0x55555555513a:       48 89 fb            mov    %rdi,%rbx
    0x55555555513d:       48 8d 7f ff         lea    -0x1(%rdi),%rdi
    0x555555555141:       e8 e3 ff ff ff      callq  1129 <rfact>
    0x555555555146:       48 0f af c3         imul   %rbx,%rax
    0x55555555514a:       5b                  pop    %rbx
    0x55555555514b:       c3                  retq   
```


### 1. `cmp` 和 `jp` 指令

其中有两句指令是我们之前没有介绍过的：

```arm
cmp    $0x1,%rdi
jg     0x555555555139 <rfact+0x10>
```

这两条指令我们后续会相信介绍，现在先来初略了解一下。

1. `cmp    $0x1,%rdi` 指令会将 两个操作数进行比较 `%rdi - $0x1`，并将比较的结果保存到条件码中。

2. `jg     0x555555555139 <rfact+0x10>` 指令的意思是如果条件码中的比较结果是 `大于（即 %rdi > $0x1）` 就跳转至 `0x555555555139`所存储的指令，否则就继续执行下面一条指令。(jg：Jump Greater)

从含义上我们可以判断这两条指令对应的 c 语言代码是：

```c
if(n <= 1)
```

指令中的处理方式有些变化，c 语言的判断是 `n <= 1` ，而指令中的判断是 `n > 1`。虽然指令的判断相反，但整体的逻辑还是是一致的。

```
if (n > 1) 
    jump to `0x555555555139` instruction
else 
    next instruction. 
```

好了，简单了解这两句的指令之后，我们就可以从头到尾地看看这段指令是如何运行的。

### 2. 第一次调用 `n = 3`

`main` 函数传递给 `rfact` 的参数是数值 `3`，所以第一次调用 `rfact` 函数时 `n=3`。 

指令开始执行之前，我们先来看看寄存器的情况，参数保存在 %rdi 中，程序计数器指向第一条指令。

<figure>
    <img src="./doc/illustrations/recursion/recursion0102.png" width="700" alt="register" align="center">
</figure>

```arm
1 endbr64 
2 cmp    $0x1,%rdi
3 jg     0x555555555139 <rfact+0x10>
4 mov    $0x1,%eax
5 retq   
6 push   %rbx
7 mov    %rdi,%rbx
8 lea    -0x1(%rdi),%rdi
9 callq  0x555555555129 <rfact>
...
```

接下来的指令执行过程中，会通过 `cmp` 和 `jg` 指令的判断跳过第 4 和 5 行指令。

<figure>
    <img src="./doc/illustrations/recursion/recursion0101.gif" width="700" alt="register" align="center">
</figure>

当 `callq` 指令执行完成之后，Stack（栈）和寄存器的情况如下。
我们可以看到参数 %rdi ，程序计数器 %rip 以及栈中的返回地址都已经准备再次调用 `rfact` 函数自身。

另外，被保存寄存器 %rbx 中保存了变量 `n` 的值。从[运行时栈4被保存的寄存器](./运行时栈4被保存的寄存器.md)中的被保存寄存器的解释中我们可以知道，在 `n=3` 这个函数调用过程中，变量的值不会因为函数再次调用自身而改变。

<figure>
    <img src="./doc/illustrations/recursion/recursion0103.png" width="700" alt="register" align="center">
</figure>

### 3. 第二次调用 `n = 2`

`n = 2` 时的函数调用有自己的栈帧，其中保存了 %rbx 值，确保了返回 `n = 3` 函数调用时，被保存寄存器 %rbx 和调用`n = 2` 函数之前是一样的。


<figure>
    <img src="./doc/illustrations/recursion/recursion0104.gif" width="700" alt="register" align="center">
</figure>


而在 `n = 2` 函数调用期间 变量 `n` 的值也一直保存在 %rbx 中。

当 `callq` 指令执行完成之后，Stack（栈）和寄存器的情况如下。

<figure>
    <img src="./doc/illustrations/recursion/recursion0105.png" width="700" alt="register" align="center">
</figure>

### 4. 第三次调用 `n = 1`

当 `n = 1` 时，会通过 `cmp` 和 `jg` 指令的判断直接执行第 4 和 5 行指令。

```arm
1 endbr64 
2 cmp    $0x1,%rdi
3 jg     0x555555555139 <rfact+0x10>
4 mov    $0x1,%eax
5 retq   
```

<figure>
    <img src="./doc/illustrations/recursion/recursion0106.gif" width="700" alt="register" align="center">
</figure>

指令将返回值设为 `1` 后，就返回 `n=2` 的函数。

### 5. 返回



```arm
0000000000001129 <rfact>:
    1129:       f3 0f 1e fa             endbr64 
    112d:       48 83 ff 01             cmp    $0x1,%rdi
    1131:       7f 06                   jg     1139 <rfact+0x10>
    1133:       b8 01 00 00 00          mov    $0x1,%eax
    1138:       c3                      retq   
    1139:       53                      push   %rbx
    113a:       48 89 fb                mov    %rdi,%rbx
    113d:       48 8d 7f ff             lea    -0x1(%rdi),%rdi
    1141:       e8 e3 ff ff ff          callq  1129 <rfact>
    1146:       48 0f af c3             imul   %rbx,%rax
    114a:       5b                      pop    %rbx
    114b:       c3                      retq   

000000000000114c <main>:
    114c:       f3 0f 1e fa             endbr64 
    1150:       48 83 ec 08             sub    $0x8,%rsp
    1154:       bf 03 00 00 00          mov    $0x3,%edi
    1159:       e8 cb ff ff ff          callq  1129 <rfact>
    115e:       b8 00 00 00 00          mov    $0x0,%eax
    1163:       48 83 c4 08             add    $0x8,%rsp
    1167:       c3                      retq   
    1168:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
    116f:       00 

Dump of assembler code for function main:
=> 0x000055555555514c <+0>:     endbr64 
   0x0000555555555150 <+4>:     sub    $0x8,%rsp
   0x0000555555555154 <+8>:     mov    $0x3,%edi
   0x0000555555555159 <+13>:    callq  0x555555555129 <rfact>
   0x000055555555515e <+18>:    mov    $0x0,%eax
   0x0000555555555163 <+23>:    add    $0x8,%rsp
   0x0000555555555167 <+27>:    retq  

(gdb) print /x $rbx
$1 = 0x555555555170

=> 0x0000555555555129 <+0>:     endbr64 
   0x000055555555512d <+4>:     cmp    $0x1,%rdi
   0x0000555555555131 <+8>:     jg     0x555555555139 <rfact+16>
   0x0000555555555133 <+10>:    mov    $0x1,%eax
   0x0000555555555138 <+15>:    retq   
   0x0000555555555139 <+16>:    push   %rbx
   0x000055555555513a <+17>:    mov    %rdi,%rbx
   0x000055555555513d <+20>:    lea    -0x1(%rdi),%rdi
   0x0000555555555141 <+24>:    callq  0x555555555129 <rfact>
   0x0000555555555146 <+29>:    imul   %rbx,%rax
   0x000055555555514a <+33>:    pop    %rbx
   0x000055555555514b <+34>:    retq   

main 
initial %rsp 0x7fffffffdfe8
before call $2 = 0x7fffffffdfe0

n=3 %rdi
initial %rbx  0x555555555170 %rsp  0x7fffffffdfd8
before callq  %rbx 0x3 %rdi 0x2 %rsp 0x7fffffffdfd0

n=2 &rdi
initial %rbx  0x3 %rsp 0x7fffffffdfc8
before callq  %rbx 0x2 %rdi 0x1 %rsp 0x7fffffffdfc0

n=1 %rdi
initial %rbx  0x2 %rsp 0x7fffffffdfb8
0x7fffffffdfb8 0x555555555146
before callq  %rbx 0x1  %rax 0x1

```

# 作用域

# 编程思维