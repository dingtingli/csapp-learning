# 递归

这个系列是我学习《深入理解计算机系统》的笔记。

本篇文章是学习第三章的第十四篇笔记，对应书本 3.7.6 节的内容。

[上一篇笔记](./13循环.md)中我们介绍了循环语句对应的指令形式，今天我们来看一个更大的循环，函数自身的循环——递归。

在看这篇文章之前，最好能回顾一下之前讲解的几个知识点，[栈帧](./09运行时栈.md) 和 [条件分支](./12条件控制.md)。

笔记分为 3 个部分：

* 什么是递归
* 递归的运行
* 状态机
* 编程思维

## 1. 什么是递归（recursion）

[上一篇笔记](./13循环.md)中我们用 while 循环实现了阶乘的求解。这次我们试着用递归的方式再来实现一下阶乘的求解。

阶乘写作 n!，含义为 n!=1×2×3×...×(n-1)×n。

用递归的方式来思考，n! = n * (n-1)！。意思是我们只要知道了 (n-1)！就可以求出 n! 。

打个比方，3！= 3 * 2！，而 2！ = 2 * 1！，最终只要知道 1！阶乘就可以返回去推导出 3！。

用 c 语言代码来实现一下阶乘的递归算法：
```c
long rfact(long n)
{
    long result;

    if(n <= 1)
        result = 1;
    else
        result = n * rfact(n-1);
    
    return result;
}

int main()
{
    long i = rfact(3);
    return 0;
}
```

代码中 `rfact` 函数就实现了 `n！` 的求解。

其中 `result = n * rfact(n-1);` 的意思就是 `n! = n * (n-1)！`。这句代码中我们可以看到 `rfact` 函数内部调用了自己，这就是**递归**——函数可以调用自身。

那这段代码是如何运行的，我们通过观察 Stack（栈）和寄存器的变化来详细了解一下。

## 2. 递归的运行

首先查看一下 `rfact` 函数的指令形式：

```arm
0x555555555129 <rfact>:
    0x555555555129:       f3 0f 1e fa         endbr64 
    0x55555555512d:       48 83 ff 01         cmp    $0x1,%rdi
    0x555555555131:       7f 06               jg     0x555555555139 <rfact+0x10>
    0x555555555133:       b8 01 00 00 00      mov    $0x1,%eax
    0x555555555138:       c3                  retq   
    0x555555555139:       53                  push   %rbx
    0x55555555513a:       48 89 fb            mov    %rdi,%rbx
    0x55555555513d:       48 8d 7f ff         lea    -0x1(%rdi),%rdi
    0x555555555141:       e8 e3 ff ff ff      callq  1129 <rfact>
    0x555555555146:       48 0f af c3         imul   %rbx,%rax
    0x55555555514a:       5b                  pop    %rbx
    0x55555555514b:       c3                  retq   
```

### 2.1 条件分支

```arm
cmp    $0x1,%rdi
jg     0x555555555139 <rfact+0x10>
```

前两句指令是由 `cmp` 和 `jg` 组成的[条件分支](./12条件控制.md)，对应的是 c 语言中的 `if(n <= 1)` 语句。

转换成指令后的意思是：

```c
if (n > 1) 
    jump to `0x555555555139` instruction
else 
    next instruction.   // mov    $0x1,%eax
                        //calculate 1!
```

### 2.2 第一次调用函数 (n=3)

`main` 函数传递给 `rfact` 的参数是数值 `3`，所以第一次调用 `rfact` 函数时 `n=3`。 

指令开始执行之前，我们先来看看寄存器的情况：参数保存在 %rdi 中，程序计数器指向第一条指令。

<figure>
    <img src="../doc/illustrations/recursion/recursion0102.PNG" width="700" alt="register" align="center">
</figure>

接下来的指令执行过程中，会通过 `cmp` 和 `jg` 指令的判断跳过第 4 和 5 行指令，从第 6 行指令开始执行。

```arm
1 endbr64 
2 cmp    $0x1,%rdi
3 jg     0x555555555139 <rfact+0x10>
4 mov    $0x1,%eax
5 retq   
6 push   %rbx
7 mov    %rdi,%rbx
8 lea    -0x1(%rdi),%rdi
9 callq  0x555555555129 <rfact>
...
```

我们通过动图来看看一步一步执行指令的过程。

<figure>
    <img src="../doc/illustrations/recursion/recursion0101.gif" width="700" alt="register" align="center">
</figure>

当 `callq` 指令执行完成之后，Stack（栈）和寄存器的情况如下。

<figure>
    <img src="../doc/illustrations/recursion/recursion0103.PNG" width="700" alt="register" align="center">
</figure>

我们可以看到参数 `%rdi` 等于 `2` ，程序计数器 %rip 以及栈中的返回地址都已经准备再次调用 `rfact` 函数自身。

另外，被保存寄存器 %rbx 中保存了变量 `n` 的值 `3`。从[栈帧的布局](./10栈帧的布局.md)中我们知道所谓**被保存寄存器**，就是在函数返回时，该值还会被恢复到相应寄存器中。

### 2.3 第二次调用函数 (n=2)

`n = 2` 时调用函数自身，还会为函数再生成一个栈桢。

栈帧中首先保存了**被保存寄存器** %rbx 值，确保了返回 `n = 3` 函数调用时，被保存寄存器 %rbx 的值和调用`n = 2` 函数之前是一样的。

而在 `n = 2` 函数调用期间，变量 `n` 的值也一直保存在 %rbx 中。

我们可以看到在每个栈帧运行时，寄存器 %rdi 保存着当前函数调用的参数 n ，而上一个函数调用时的参数就会通过**被保存寄存器**和栈一起，来保证在当前栈帧运行时该值始终一致。

<figure>
    <img src="../doc/illustrations/recursion/recursion0104.gif" width="700" alt="register" align="center">
</figure>

当 `callq` 指令执行完成之后，Stack（栈）和寄存器的情况如下。

<figure>
    <img src="../doc/illustrations/recursion/recursion0105.PNG" width="700" alt="register" align="center">
</figure>

可以看到参数 `%rdi` 等于 `1` ，程序计数器 %rip 以及栈中的返回地址都已经准备第三次调用 `rfact` 函数自身。

### 2.4 第三次调用函数 (n=1)

当 `n = 1` 时，会通过 `cmp` 和 `jg` 指令的判断直接执行第 4 和 5 行指令。

```arm
1 endbr64 
2 cmp    $0x1,%rdi
3 jg     0x555555555139 <rfact+0x10>
4 mov    $0x1,%eax
5 retq   
```

<figure>
    <img src="../doc/illustrations/recursion/recursion0106.gif" width="700" alt="register" align="center">
</figure>

这一段指令完成了 `1!` 的计算，并将结果 `1` 返回给 `n=2` 的函数。

### 2.5 返回返回

返回 `n=2` 的函数后，会执行剩下的指令：

```arm
imul   %rbx,%rax
pop    %rbx
retq   
```

上述指令的意思是：

1. 将从 `n=1` 函数返回的值 `1` ，与 `n=2` 函数中的变量 `n`(值为 `2`)相乘，相乘的结果 `2` 设置为 `n=2` 函数的返回值。

2. 在返回 `n=3` 的函数之前，我们会将 %rbx 恢复为 `3`。

<figure>
    <img src="../doc/illustrations/recursion/recursion0107.gif" width="700" alt="register" align="center">
</figure>

之后会返回 `n=3` 的函数，执行的指令与上面相同。

将从 `n=2` 函数返回的值 `2` ，与 `n=3` 函数中的变量 `n`(值为 `3`)相乘，乘积 `6` 设置为 `n=3` 函数的返回值。

<figure>
    <img src="../doc/illustrations/recursion/recursion0108.gif" width="700" alt="register" align="center">
</figure>

至此，整个递归过程运行结束。

## 3. 状态机



## 4. 编程思维

递归之所以让人不太容易理解，是因为它跟人类的正常思维不太一样，人类的正向思维是从小到大，由易到难，从局部到整体。

比如求 5 的阶乘（`5！`），人们习惯从小到大一个一个乘起来，即 `5！= 1 * 2 * 3 * 4 * 5`。

在递归中会将过程倒过来，要算 `5!` 先假定 `4!` 是已知的，然后再乘以 5 就可以了。那么 `4! `阶乘怎么算？同样，假定 `3!` 已知……以此类推，直到 `1! `时，我们知道它等于 1 ，从这就不再往下扩展，而是倒回去推出所有的结果，从 `1!` ,` 2!` 直到推回 `5！`.

递归就很不直观的逆向思维，它从大到小，从整体到局部，属于计算机特有的思维方式。

它必须具备两个条件：
1. 首先需要确定好结束条件，
2. 其次，在每个问题的形式上都相同，只要解决当前问题就能解决整个问题。

有些问题上，递归这种逆向思维会让问题变得非常简单。比如八皇后问题,汉诺塔问题，如果从小到大，一步一步推导问题复杂的为呈现指数级别的上升，但是递归只需要知道如何拆解问题即可，计算机可以帮忙快速的处理出现的几万种情况。

但是也需要注意递归的深度，从上面的运行情况来看，每一次递归都需要消耗 Stack 的空间，如果超过了 Stack 的大小 8 M， 就会出现栈溢出的情况。

总的来说，递归是一个程序员必须掌握的计算机思维。

## 总结

