# 条件码寄存器（Condition Code）

在介绍[递归](./递归.md)的时候，我们使用到了条件码寄存器，当时只是粗略介绍了一下，了解到条件码寄存器中保存的是条件判断的结果，这次我们来详细了解一下什么是条件码寄存器。

## 定义

条件码寄存器（condition code register）：主要有 4 个寄存器，每个寄存器 1 位，用于存储最近执行的算术或逻辑指令的状态信息。

这 4 个寄存器分别是：

* CF（carry flag）：进位标志，检查无符号操作的溢出情况，有溢出时设为 1。
* ZF（zero flag）：零标志，最近操作结果为 0 时设为 1。
* SF（sign flag）：符号标志，最近操作结果为负数时设为 1。
* OF（overflow flag）：溢出标志，最近有符号数操作导致补码溢出——正溢出或者负溢出，有补码溢出时设为 1。

以 t = a + b 为例，先介绍两个简单的标志：
 * 如果结果等于 0 ，ZF 零标志设为 1。用公式表示为 `t == 0`
 * 如果结果为负数，SF 符号标志设为 1。用公式表示为 `t < 0`

### CF 进位标志

CF 进位标志，是在 a 和 b 都是无符号数的情况下发生，当 a + b 的结果 t 小于 a 或者 b 时，CF 进位标志设为 1。

我们以 4 位的无符号整数为例，假设 `a = 10`，`b = 8`，`a + b` 的情况如下：

<figure>
    <img src="./doc/illustrations/condition/condition0101.gif" width="700" alt="register" align="center">
</figure>

`a + b` 的计算结果 `18` 超出了 4 位无符号整数的最大值 `15`，超出的位数将会丢弃，最终结果 `t` 为 `2`。这时候因为发生了无符号操作的溢出，所以 CF 进位标志将设置为 `1`。

简化成公式，就是 `(unsigned) t < (unsigned) a`（只要跟一个加数比较即可，`a` 或者 `b` 都可以）。

### OF 溢出标志
 
OF 溢出标志是为了有符号的补码出现溢出情况时准备的。

我们以 4 位的有符号整数为例，首先考虑补码正溢出的情况。假设 `a = 3`， `b = 6`，这时候 `a + b` 的情况如下：

<figure>
    <img src="./doc/illustrations/condition/condition0102.gif" width="700" alt="register" align="center">
</figure>

 `a + b` 的结果 `t` 是 `9`， 但作为 4 位的有符号整数，这个二进制表示为 `-7`，这就是所谓的补码正溢出的情况，出现这种情况，OF 溢出标志将设置为 `1`，同时因为结果为负数，所以还会将 SF 符号标志也设置为 `1`。

 简化成公式，就是 `a >= 0 && b >= 0 && t < 0`（注意 等于 0 的情况，考虑 a 和 b 都是 `0`）。

 再来看看补码负溢出的情况，假设 `a = -8`，`b = -5`，这时候 `a + b` 的情况如下：

 <figure>
    <img src="./doc/illustrations/condition/condition0103.gif" width="700" alt="register" align="center">
</figure>

 `a + b` 的结果 `t` 是 `-13`， 但作为 4 位的有符号整数，超出的位数将会丢弃,这个二进制表示为 `3`，这就是所谓的补码负溢出的情况，出现这种情况，OF 溢出标志将设置为 `1`。

 简化成公式，就是 `a < 0 && b < 0 && t >= 0`（注意 等于 0 的情况，考虑 a 和 b 都是 `-8`）。

 这就是补码正溢出和负溢出的情况。我们将两个公式一起看一下：

 * 补码正溢出时的公式：`a >= 0 && b >= 0 && t < 0`
 * 补码负溢出时的公式：`a < 0 && b < 0 && t >= 0`

书中将这两个公式合成了一个公式：

* 公式的前半段是 `(a<0) == (b<0)`，这种写法既保证了 `a >= 0 && b >= 0`成立，同时又保证了 `a < 0 && b < 0 ` 也成立。

    公式的前半段已经保证了 `a` 和 `b` 要么同时 `>=0`，要么同时 `<0`，

* 公式的后半段是 `(t<0) != (a<0)`。
    
    如果 `(t<0)`为`true` 并且 `a<0`为 `false` 时，公式成立，此时对应的是补码正溢出。

    或者，如果 `(t<0)`为`false` 并且 `a<0`为 `true` 时，公式成立，，此时对应的是补码负溢出。

    *当然，公式后半段也可以写成 `(t<0) == (a>=0)`。

最终公式为： `((a<0) == (b<0)) && (t<0) != (a<0)`。

### 对应公式

现在，我们得到了四个条件码在 `t = a + b` 情况下所对应的的公式：

* CF（carry flag），进位标志：`(unsigned) t < (unsigned) a`
* ZF（zero flag），零标志：`t == 0`
* SF（sign flag），符号标志：`t < 0`
* OF（overflow flag），溢出标志：`((a<0) == (b<0)) && (t<0) != (a<0)`

## 哪些指令会对条件码寄存器产生影响

之前[二元操作](./指令集6二元操作.md)介绍过，加法对应的指令为 `add`，所以该指令在执行时除了会修改操作数的结果之外，还会修改条件码寄存器中的标志。

我们之前在[一元操作](./指令集5一元操作.md)和[二元操作](./指令集6二元操作.md)中介绍的指令都会设置条件码寄存器中的标志。

那些不做运算的指令，比如 `mov`，`leaq`，`push`， `pop`，`call`， `ret` 等就不会对条件码寄存器中的标志进行操作。

## `CMP` 和 `TEST` 指令




## `SET` 指令

```arm
comp 5,-8
setl %al
```

 <figure>
    <img src="./doc/illustrations/condition/condition0104.gif" width="700" alt="register" align="center">
</figure>

## 总结

